equal_prob

(*
    https://openqasm.com/grammar/index.html for full grammar.
*)

# Keywords 
INCLUDE : "include";
BREAK: "break";
CONTINUE: "continue";
END: "end";
FOR: "for";
IF : "if";
ELSE: "else";
RETURN: "return";
WHILE: "while";
SWITCH: "switch";
CASE: "case";
OPENQASM: "OPENQASM";
PRAGMA: ("#")? "pragma";
DEF: 'def';
GATE: 'gate';
EXTERN: 'extern';
BOX: 'box';
LET: 'let';

# Builtin identifiers and operations
GPHASE: 'gphase';
INV: 'inv';
POW: 'pow';
CTRL: 'ctrl';
NEGCTRL: 'negctrl';
DIM: '#dim';
DURATIONOF: 'durationof';
DELAY: 'delay';
RESET: 'reset';
MEASURE: 'measure';
BARRIER: 'barrier';
BooleanLiteral: 'true' | 'false';

# Symbols
LPAREN: "(";
RPAREN: ")";
LBRACKET: "[";
RBRACKET: "]";
LBRACE: "{";
RBRACE: "}";

SEMICOLON : ";";
COLON: ":";
DOT: ".";
COMMA: ",";
EQUALS: '=';
ARROW: '->';
PLUS: '+';
DOUBLE_PLUS: '++';
MINUS: '-';
ASTERISK: '*';
DOUBLE_ASTERISK: '**';
SLASH: '/';
PERCENT: '%';
PIPE: '|';
DOUBLE_PIPE: '||';
AMPERSAND: '&';
DOUBLE_AMPERSAND: '&&';
CARET: '^';
AT: '@';
TILDE: '~';
EXCLAMATION_POINT: '!';

EqualityOperator: '==' | '!=';
CompoundAssignmentOperator: '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '~=' | '^=' | '<<=' | '>>=' | '%=' | '**=';
ComparisonOperator: '>' | '<' | '>=' | '<=';
BitshiftOperator: '>>' | '<<';

NEWLINE: "\n";

# Types
INPUT: 'input';
OUTPUT: 'output';
CONST: 'const';
READONLY: 'readonly';
MUTABLE: 'mutable';
QREG: 'qreg';
QUBIT: 'qubit';
CREG: 'creg';
BOOL: 'bool';
BIT: 'bit';
INT: 'int';
UINT: 'uint';
FLOAT: 'float';
ANGLE: 'angle';
COMPLEX: 'complex';
ARRAY: 'array';
VOID: 'void';
DURATION:  'duration';
STRETCH: 'stretch';

Letter: "a" - "z" | "A" - "Z";
FirstIdCharacter: '_' | Letter;
GeneralIdCharacter: FirstIdCharacter | '0'-'9';

Identifier: FirstIdCharacter (GeneralIdCharacter)*;

program: (version)? (includeStatement NEWLINE)* (statementOrScope)*;
version: OPENQASM VersionSpecifier SEMICOLON;
VersionSpecifier: "3.0";

statement:
    pragma NEWLINE
    | (
        aliasDeclarationStatement
        | assignmentStatement
        | barrierStatement
        | boxStatement
        | breakStatement
        | calStatement
        | calibrationGrammarStatement
        | classicalDeclarationStatement
        | constDeclarationStatement
        | continueStatement
        | defStatement
        | defcalStatement
        | delayStatement
        | endStatement
        | expressionStatement
        | externStatement
        | forStatement
        | gateCallStatement
        | gateStatement
        | ifStatement
        | includeStatement
        | ioDeclarationStatement
        | measureArrowAssignmentStatement
        | oldStyleDeclarationStatement
        | quantumDeclarationStatement
        | resetStatement
        | returnStatement
        | switchStatement
        | whileStatement
    ) NEWLINE
;

scope: LBRACE (statementOrScope)* RBRACE;
statementOrScope: statement | scope;
pragma: PRAGMA;

(* Start top-level statement definitions. *)

# Inclusion statements
includeStatement: INCLUDE StringLiteral SEMICOLON;

# Control flow statements

# Quantum directive statements.
barrierStatement: BARRIER (gateOperandList)? SEMICOLON;
boxStatement: BOX (designator)? scope;
delayStatement: DELAY designator (gateOperandList)? SEMICOLON;

(* `gateCallStatement`  is split in two to avoid a potential ambiguity with an
 * `expressionStatement` that consists of a single function call.  The only
 * "gate" that can have no operands is `gphase` with no control modifiers, and
 * `gphase(pi);` looks grammatically identical to `fn(pi);`.  We disambiguate by
 * having `gphase` be its own token, and requiring that all other gate calls
 * grammatically have at least one qubit.  Strictly, as long as `gphase` is a
 * separate token, ANTLR can disambiguate the statements by the definition
 * order, but this is more robust. *)

gateCallStatement:
    (gateModifier)* Identifier (LPAREN (expressionList)? RPAREN)? (designator)? gateOperandList SEMICOLON
    | (gateModifier)* GPHASE (LPAREN (expressionList)? RPAREN)? (designator)? (gateOperandList)? SEMICOLON
;

# measureArrowAssignmentStatement also permits the case of not assigning the
# result to any classical value too.

measureArrowAssignmentStatement: measureExpression (ARROW indexedIdentifier)? SEMICOLON;
resetStatement: RESET gateOperand SEMICOLON;

# Primitive declaration statements.
aliasDeclarationStatement: LET Identifier EQUALS aliasExpression SEMICOLON;
classicalDeclarationStatement: (scalarType | arrayType) Identifier (EQUALS declarationExpression)? SEMICOLON;
constDeclarationStatement: CONST scalarType Identifier EQUALS declarationExpression SEMICOLON;
ioDeclarationStatement: (INPUT | OUTPUT) (scalarType | arrayType) Identifier SEMICOLON;
oldStyleDeclarationStatement: (CREG | QREG) Identifier (designator)? SEMICOLON;
quantumDeclarationStatement: qubitType Identifier SEMICOLON;

#  Declarations and definitions of higher-order objects.
defStatement: DEF Identifier LPAREN (argumentDefinitionList)? RPAREN (returnSignature)? scope;
externStatement: EXTERN Identifier LPAREN (externArgumentList)? RPAREN (returnSignature)? SEMICOLON;
gateStatement: GATE Identifier (LPAREN params=(identifierList)? RPAREN)? qubits=identifierList scope;

#  Non-declaration assignments and calculations.
assignmentStatement: indexedIdentifier op=(EQUALS | CompoundAssignmentOperator) (expression | measureExpression) SEMICOLON;
expressionStatement: expression SEMICOLON;

#  Statements where the bulk is in the calibration language.
calStatement: CAL LBRACE (CalibrationBlock)? RBRACE;
defcalStatement: DEFCAL defcalTarget (LPAREN (defcalArgumentDefinitionList)? RPAREN)? defcalOperandList (returnSignature)? LBRACE (CalibrationBlock)? RBRACE;

(* End top-level statement definitions. *)
(* Start expression definitions. *)

expression:
    LPAREN expression RPAREN                                  # parenthesisExpression
    | expression indexOperator                                # indexExpression
    | expression DOUBLE_ASTERISK expression                   # powerExpression
    | (TILDE | EXCLAMATION_POINT | MINUS) expression       # unaryExpression
    | expression (ASTERISK | SLASH | PERCENT) expression   # multiplicativeExpression
    | expression (PLUS | MINUS) expression                 # additiveExpression
    | expression BitshiftOperator expression               # bitshiftExpression
    | expression ComparisonOperator expression             # comparisonExpression
    | expression EqualityOperator expression               # equalityExpression
    | expression AMPERSAND expression                      # bitwiseAndExpression
    | expression CARET expression                          # bitwiseXorExpression
    | expression PIPE expression                           # bitwiseOrExpression
    | expression DOUBLE_AMPERSAND expression               # logicalAndExpression
    | expression DOUBLE_PIPE expression                    # logicalOrExpression
    | (scalarType | arrayType) LPAREN expression RPAREN       # castExpression
    | DURATIONOF LPAREN scope RPAREN                          # durationofExpression
    | Identifier LPAREN (expressionList)? RPAREN                # callExpression
    | (
        Identifier
        | BinaryIntegerLiteral
        | OctalIntegerLiteral
        | DecimalIntegerLiteral
        | HexIntegerLiteral
        | FloatLiteral
        | ImaginaryLiteral
        | BooleanLiteral
        | BitstringLiteral
        | TimingLiteral
        | HardwareQubit
      )                                                       # literalExpression
;

indexOperator:
    LBRACKET
    (
        setExpression
        | (expression | rangeExpression) (COMMA (expression | rangeExpression))* (COMMA)?
    )
    RBRACKET;

indexedIdentifier: Identifier (indexOperator)*;

# Start type definitions.

returnSignature: ARROW scalarType;

gateModifier: (
    INV
    | POW LPAREN expression RPAREN
    | (CTRL | NEGCTRL) (LPAREN expression RPAREN)?
) AT;

scalarType:
    BIT (designator)?
    | INT (designator)?
    | UINT (designator)?
    | FLOAT (designator)?
    | ANGLE (designator)?
    | BOOL
    | DURATION
    | STRETCH
    | COMPLEX (LBRACKET scalarType RBRACKET)?
;

qubitType: QUBIT (designator)?;
arrayType: ARRAY LBRACKET scalarType COMMA expressionList RBRACKET;
arrayReferenceType: (READONLY | MUTABLE) ARRAY LBRACKET scalarType COMMA (expressionList | DIM EQUALS expression) RBRACKET;

designator: LBRACKET expression RBRACKET;

defcalTarget: MEASURE | RESET | DELAY | Identifier;
defcalArgumentDefinition: expression | argumentDefinition;
defcalOperand: HardwareQubit | Identifier;
gateOperand: indexedIdentifier | HardwareQubit;
externArgument: scalarType | arrayReferenceType | CREG (designator)?;

argumentDefinition:
    scalarType Identifier
    | qubitType Identifier
    | (CREG | QREG) Identifier (designator)?
    | arrayReferenceType Identifier
;

argumentDefinitionList: argumentDefinition (COMMA argumentDefinition)* (COMMA)?;
defcalArgumentDefinitionList: defcalArgumentDefinition (COMMA defcalArgumentDefinition)* (COMMA)?;
defcalOperandList: defcalOperand (COMMA defcalOperand)* (COMMA)?;
expressionList: expression (COMMA expression)* (COMMA)?;
identifierList: Identifier (COMMA Identifier)* (COMMA)?;
gateOperandList: gateOperand (COMMA gateOperand)* (COMMA)?;
externArgumentList: externArgument (COMMA externArgument)* (COMMA)?;